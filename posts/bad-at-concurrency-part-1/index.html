<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>I'm Bad at Concurrency in Go | penick.io</title><meta name=keywords content="golang,concurrency"><meta name=description content="Improving at concurrency in Go (Part 1)"><meta name=author content="Mike"><link rel=canonical href=https://penick.io/posts/bad-at-concurrency-part-1/><link crossorigin=anonymous href=/assets/css/stylesheet.min.0a42eff6299c37e4db89c888dbe7cdeb2ea254e7167b127d3194571614fc56e1.css integrity="sha256-CkLv9imcN+TbiciI2+fN6y6iVOcWexJ9MZRXFhT8VuE=" rel="preload stylesheet" as=style><link rel=preload href=/logo.svg as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://penick.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://penick.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://penick.io/favicon-32x32.png><link rel=apple-touch-icon href=https://penick.io/apple-touch-icon.png><link rel=mask-icon href=https://penick.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.97.3"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/tomorrow-night.min.css integrity="sha512-Ly91v1PH9MuXZoEzAV762yfHfn7sAaUHOrv5a3d27/Pk6trrRcEJTXQrU3lgxC/v4+CzRqAK68hnHnDx2agvng==" crossorigin=anonymous referrerpolicy=no-referrer><script async src="https://www.googletagmanager.com/gtag/js?id=G-5W3FXW77RG"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5W3FXW77RG",{anonymize_ip:!1})}</script><meta property="og:title" content="I'm Bad at Concurrency in Go"><meta property="og:description" content="Improving at concurrency in Go (Part 1)"><meta property="og:type" content="article"><meta property="og:url" content="https://penick.io/posts/bad-at-concurrency-part-1/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-23T00:00:00+00:00"><meta property="article:modified_time" content="2023-01-23T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="I'm Bad at Concurrency in Go"><meta name=twitter:description content="Improving at concurrency in Go (Part 1)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://penick.io/posts/"},{"@type":"ListItem","position":2,"name":"I'm Bad at Concurrency in Go","item":"https://penick.io/posts/bad-at-concurrency-part-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"I'm Bad at Concurrency in Go","name":"I\u0027m Bad at Concurrency in Go","description":"Improving at concurrency in Go (Part 1)","keywords":["golang","concurrency"],"articleBody":"Recently, I came across a hypothetical Go concurrency problem. It’s a simple, toy problem that’s a potentially useful thought experiment for solving real-world problems. It’s also interesting because it has potential opportunity to be built on and improved. The problem goes like this, given:\ntype Point struct { // Stuff, doesn't matter } func ExpensiveServiceCall(point Point) bool { // Really expensive call to remote service } func ScatterShot(points []Point) bool { // Implement me } you’re suppose to implement ScatterShot(point []Point) bool which returns true when one of the points “hits”, that is, when a call toExpensiveServiceCall(point Point) bool returns true. It should be implemented in such a way to minimize the run time when given a large number of points which (likely) means making multiple concurrent calls to the “expensive” service. After little bit of thought, I started work on the problem, and what I came up with was not very good.\nUnbounded channels My first attempt, uses a goroutine for each point in points sending the results back, to the outer function, on a unbounded channel. A sync.WaitGroup is used to prevent the outer function from returning before calculating all the results. Here’s what that looks like:\nfunc ScatterShotReallyBad(points []Point) bool { ch := make(chan bool) var wg sync.WaitGroup wg.Add(len(points)) go func() { wg.Wait() close(ch) }() for i, p := range points { go func(idx int, point Point) { r := ExpensiveServiceCall(point) if r { ch  r // This can hang, causing a goroutine leak \t} wg.Done() fmt.Printf(\"Point %d done\\n\", idx) }(i, p) } for r := range ch { return r } return false } If you run this, there will be times when goroutines will hang (and never return) because the unbounded channel blocks when there’s no longer a receiver which happens when the ScatterShot() function returns. So if you run something like:\nfunc main() { points := []Point{{}, {}, {}, {}, {}, {}, {}, {}, {}, {}} // 10 points \tScatterShotReallyBad(points) } the following can happen and some goroutines will fail to print that they’re done:\nPoint 2 done Point 3 done Point 9 done Point 8 done Point 4 done Point 5 done Point 7 done Point 0 done Point 1 done Where’s Point 6 done? Uh oh!\nOne potentially bad solution is to use a select{} block with a default: case to prevent the channel from blocking:\n// ... go func(idx int, point Point) { r := ExpensiveServiceCall(point) if r { select { case ch  r: default: // If the channel blocks, take the default case  } } wg.Done() fmt.Printf(\"Point %d done\\n\", idx) }(i, p) It prevents the goroutines from hanging (and leaking), but it creates another problem! Can you spot the problem?\nIt causes ScatterShotSimple() to, sporadically, return incorrect results. This is because it’s possible for goroutines to miss points that “hit” if the channel isn’t receiving yet in the outer function. In that situation, the select{} block chooses the default: case causing it to never send the result.\nUnbounded channels are not a good fit for this problem!\nBounded channels Not only does the initial solution not work correctly, it’s overly complex. It turns out that if you use a bounded channel then things fall into place and the solution is quite elegant. A bounded channel makes complete sense here because we know the total size of the problem we’re trying to solve: len(points), and this is size to use when creating the buffered channel:\nfunc ScatterShotSimple(points []Point) bool { ch := make(chan bool, len(points)) for i, p := range points { go func(idx int, point Point) { ch  ExpensiveServiceCall(point) fmt.Printf(\"Point %d done\\n\", idx) }(i, p) } for range points { if ch { return true } } return false } With this solution, the sender never blocks because the buffered channel is always big enough. The outer function doesn’t return prematurely because we wait for len(points) results on the shared channel before returning. This simple solution is quite nice, but it still has problems:\n It has a goroutine leak. If a point “hits” then the outer function returns immediately potentially leaving spawned goroutines running in the background. It creates an unbounded number of concurrent calls to the “expensive” service, potentially overwhelming it. Calls to the “expensive” service are made in a tight loop potentially causing a very high request rate that is also likely to overwhelm the service.  How might this be improved? Hint: Go gives us the tools to deal with this.\nUsing context.Context That’s right! We should be using a context.Context to manage the lifetimes of goroutines, but that means we need to redefine our problem a bit; the expensive call also needs respect the use of a context.Context we pass to it:\nfunc ExpensiveServiceCallWithContext(ctx context.Context, point Point) bool { // Really expensive call to remote service, but with a context } Now with context.Context in place we can re-write our function:\nfunc ScatterShotSimpleWithContext(ctx context.Context, points []Point) bool { ctx, cancel := context.WithCancel(ctx) defer cancel() // This will cancel any in progress calls  ch := make(chan bool, len(points)) for i, p := range points { go func(idx int, point Point) { ch  ExpensiveServiceCallWithContext(ctx, point) fmt.Printf(\"Point %d done\\n\", idx) }(i, p) } for range points { if ch { return true } } return false } The first time this was written I did not use context.WithCancel(), and defer cancel() in the first few lines; however, this is necessary to make sure we stop any in-progress goroutines. ScatterShotSimpleWithContext() shouldn’t rely on the caller to cancel goroutines that it’s created.\nIt’s looking better, but it could still overwhelm our “expensive” service! One way we could prevent that is by limiting the amount of concurrency by not creating a goroutine per call, and instead use a fixed pool of goroutines.\nLimiting concurrency Here’s the solution I came up with for limiting concurrency. The caller is able to control the amount of concurrency by passing a maxConcurrency parameter which limits the number of goroutines. Goroutines are no longer created and passed a point for each element in points so some other mechanism of passing points, to the already running goroutines, needs to be used. Sounds like a job for a channel (it’s important that it’s buffered, more below).\nfunc ScatterShotLimitConcurrency(ctx context.Context, maxConcurrency int, points []Point) bool { ctx, cancel := context.WithCancel(ctx) defer cancel() // This will cancel any in progress calls  pointsCh := make(chan Point) resultCh := make(chan bool, len(points)) // Avoid creating more goroutines than are necessary \tif maxConcurrency  len(points) { maxConcurrency = len(points) } // Use a goroutine to send points to the workers without delaying \t// this function. \tgo func() { defer close(pointsCh) // Signal the workers we're done  for _, p := range points { select { case pointsCh  p: case ctx.Done(): return } } }() // Start workers \tfor i := 0; i  maxConcurrency; i++ { go func() { for p := range pointsCh { resultCh  ExpensiveServiceCallWithContext(ctx, p) } }() } for range points { if resultCh { return true } } return false } When implementing this there were some subtleties I missed on the first pass. The first, was feeding points to workers in the main function instead of a goroutine could delay an early return because it takes some amount of time to send all the points to a channel, even if it’s buffered. This delay is probably not significant for a small number of points, but sending points on a separate goroutine also sets this up nicely for rate limiting (spoiler). Second, I didn’t limit maxConcurrency when it exceeds the number of points which results in creating more goroutines than are necessary to solve the problem. Also, notice that sending on the unbuffered pointsCh might block so we also need to have a case in the select {} block for when the context is done.\nThere’s at least one major improvement we can make to our ScatterShot() function and that’s to limit the request rate in each of the worker goroutines.\nRate limiting In all previous solutions, we process the points by calling the “expensive” service as fast as the local machine can make the requests. This is likely to overwhelm the service. One possible solution is to limit the total request rate by feeding pointsCh at a rate controlled by a timer.Ticker. Because the timer.Ticker blocks execution of goroutine (or function) it can’t be done in the body of ScatterShotRateLimited() and it must be done on a separate goroutine.\nfunc ScatterShotRateLimited(ctx context.Context, maxConcurrency int, reqsPerSec float64, points []Point) bool { ctx, cancel := context.WithCancel(ctx) defer cancel() // This will cancel any in progress calls  pointsCh := make(chan Point, maxConcurrency) resultCh := make(chan bool, len(points)) // Avoid creating more goroutines than are necessary \tif maxConcurrency  len(points) { maxConcurrency = len(points) } // Use a goroutine to feed points to the worker without blocking \t// this function. \tgo func() { defer close(pointsCh) // Signal the workers we're done  delayPerReq := time.Duration(float64(time.Second) / reqsPerSec) // Send to workers at a rate of `reqsPerSec` \trateLimiter := time.Tick(delayPerReq) for _, p := range points { select { case pointsCh  p: select { case rateLimiter: case ctx.Done(): return } case ctx.Done(): return } } }() for i := 0; i  maxConcurrency; i++ { go func() { for p := range pointsCh { resultCh  ExpensiveServiceCallWithContext(ctx, p) } }() } for range points { if resultCh { return true } } return false } One nuance here, is while waiting on the ticker we also need a select{} block case for the context to break out when it’s done.\nSummary My initial solution to this problem was pretty rough, but I didn’t give up! I kept iterating and improving. After giving it a bit of thought, we now have solution that’s (hopefully) no more complex than it needs to be, plays nice with context.Context, doesn’t leak goroutines, and won’t overwhelm the “expensive” service.\n","wordCount":"1655","inLanguage":"en","datePublished":"2023-01-23T00:00:00Z","dateModified":"2023-01-23T00:00:00Z","author":{"@type":"Person","name":"Mike"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://penick.io/posts/bad-at-concurrency-part-1/"},"publisher":{"@type":"Organization","name":"penick.io","logo":{"@type":"ImageObject","url":"https://penick.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://penick.io/ accesskey=h title="penick.io (Alt + H)"><img src=https://penick.io/logo.svg alt=logo aria-label=logo height=32></a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://penick.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://penick.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://penick.io/archives/ title=archives><span>archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://penick.io/>Home</a>&nbsp;»&nbsp;<a href=https://penick.io/posts/>Posts</a></div><h1 class=post-title>I'm Bad at Concurrency in Go</h1><div class=post-description>Improving at concurrency in Go (Part 1)</div><div class=post-meta><span title="2023-01-23 00:00:00 +0000 UTC">January 23, 2023</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Mike</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#unbounded-channels aria-label="Unbounded channels">Unbounded channels</a></li><li><a href=#bounded-channels aria-label="Bounded channels">Bounded channels</a></li><li><a href=#using-contextcontext aria-label="Using context.Context">Using <code>context.Context</code></a></li><li><a href=#limiting-concurrency aria-label="Limiting concurrency">Limiting concurrency</a></li><li><a href=#rate-limiting aria-label="Rate limiting">Rate limiting</a></li><li><a href=#summary aria-label=Summary>Summary</a></li></ul></div></details></div><div class=post-content><p>Recently, I came across a hypothetical Go concurrency problem. It&rsquo;s a simple, toy problem that&rsquo;s a
potentially useful thought experiment for solving real-world problems. It&rsquo;s also interesting because
it has potential opportunity to be built on and improved. The problem goes like this, given:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Point</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Stuff, doesn&#39;t matter
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ExpensiveServiceCall</span><span class=p>(</span><span class=nx>point</span> <span class=nx>Point</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Really expensive call to remote service
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ScatterShot</span><span class=p>(</span><span class=nx>points</span> <span class=p>[]</span><span class=nx>Point</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Implement me
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>you&rsquo;re suppose to implement <code>ScatterShot(point []Point) bool</code> which returns <code>true</code> when one of the
points &ldquo;hits&rdquo;, that is, when a call to<code>ExpensiveServiceCall(point Point) bool</code> returns <code>true</code>. It
should be implemented in such a way to minimize the run time when given a large number of points
which (likely) means making multiple concurrent calls to the &ldquo;expensive&rdquo; service. After little bit
of thought, I started work on the problem, and what I came up with was not very good.</p><h3 id=unbounded-channels>Unbounded channels<a hidden class=anchor aria-hidden=true href=#unbounded-channels>#</a></h3><p>My first attempt, uses a goroutine for each point in <code>points</code> sending the results back, to the
outer function, on a unbounded channel. A <code>sync.WaitGroup</code> is used to prevent the outer function
from returning before calculating all the results. Here&rsquo;s what that looks like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ScatterShotReallyBad</span><span class=p>(</span><span class=nx>points</span> <span class=p>[]</span><span class=nx>Point</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>points</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nb>close</span><span class=p>(</span><span class=nx>ch</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>p</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>points</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>idx</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>point</span> <span class=nx>Point</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>r</span> <span class=o>:=</span> <span class=nf>ExpensiveServiceCall</span><span class=p>(</span><span class=nx>point</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>r</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>ch</span> <span class=o>&lt;-</span> <span class=nx>r</span> <span class=c1>// This can hang, causing a goroutine leak
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Point %d done\n&#34;</span><span class=p>,</span> <span class=nx>idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>r</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>ch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>r</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>If you run this, there will be times when goroutines will hang (and never return) because the
unbounded channel blocks when there&rsquo;s no longer a receiver which happens when the <code>ScatterShot()</code>
function returns. So if you run something like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>points</span> <span class=o>:=</span> <span class=p>[]</span><span class=nx>Point</span><span class=p>{{},</span> <span class=p>{},</span> <span class=p>{},</span> <span class=p>{},</span> <span class=p>{},</span> <span class=p>{},</span> <span class=p>{},</span> <span class=p>{},</span> <span class=p>{},</span> <span class=p>{}}</span> <span class=c1>// 10 points
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>ScatterShotReallyBad</span><span class=p>(</span><span class=nx>points</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>the following can happen and some goroutines will fail to print that they&rsquo;re done:</p><pre tabindex=0><code>Point 2 done
Point 3 done
Point 9 done
Point 8 done
Point 4 done
Point 5 done
Point 7 done
Point 0 done
Point 1 done
</code></pre><p>Where&rsquo;s <code>Point 6 done</code>? Uh oh!</p><p>One potentially bad solution is to use a <code>select{}</code> block with a <code>default:</code> case to prevent the
channel from blocking:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>idx</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>point</span> <span class=nx>Point</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>r</span> <span class=o>:=</span> <span class=nf>ExpensiveServiceCall</span><span class=p>(</span><span class=nx>point</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>r</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>ch</span> <span class=o>&lt;-</span> <span class=nx>r</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>default</span><span class=p>:</span> <span class=c1>// If the channel blocks, take the default case
</span></span></span><span class=line><span class=cl><span class=c1></span> 		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Point %d done\n&#34;</span><span class=p>,</span> <span class=nx>idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>p</span><span class=p>)</span>
</span></span></code></pre></div><p>It prevents the goroutines from hanging (and leaking), but it creates another
problem! Can you spot the problem?</p><p>It causes <code>ScatterShotSimple()</code> to, sporadically, return incorrect results. This is because it&rsquo;s
possible for goroutines to miss points that &ldquo;hit&rdquo; if the channel isn&rsquo;t receiving yet in the outer
function. In that situation, the <code>select{}</code> block chooses the <code>default:</code> case causing it to
never send the result.</p><p>Unbounded channels are not a good fit for this problem!</p><h3 id=bounded-channels>Bounded channels<a hidden class=anchor aria-hidden=true href=#bounded-channels>#</a></h3><p>Not only does the initial solution not work correctly, it&rsquo;s overly complex. It turns out that if you
use a bounded channel then things fall into place and the solution is quite elegant. A bounded
channel makes complete sense here because we know the total size of the problem we&rsquo;re trying to
solve: <code>len(points)</code>, and this is size to use when creating the buffered channel:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ScatterShotSimple</span><span class=p>(</span><span class=nx>points</span> <span class=p>[]</span><span class=nx>Point</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>bool</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>points</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>p</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>points</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>idx</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>point</span> <span class=nx>Point</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>ch</span> <span class=o>&lt;-</span> <span class=nf>ExpensiveServiceCall</span><span class=p>(</span><span class=nx>point</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Point %d done\n&#34;</span><span class=p>,</span> <span class=nx>idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=k>range</span> <span class=nx>points</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=o>&lt;-</span><span class=nx>ch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>With this solution, the sender never blocks because the buffered channel is always big enough. The
outer function doesn&rsquo;t return prematurely because we wait for <code>len(points)</code> results on the shared
channel before returning. This simple solution is quite nice, but it still has problems:</p><ul><li>It has a goroutine leak. If a point &ldquo;hits&rdquo; then the outer function returns immediately potentially
leaving spawned goroutines running in the background.</li><li>It creates an unbounded number of concurrent calls to the &ldquo;expensive&rdquo; service, potentially
overwhelming it.</li><li>Calls to the &ldquo;expensive&rdquo; service are made in a tight loop potentially causing a very high request
rate that is also likely to overwhelm the service.</li></ul><p>How might this be improved? Hint: Go gives us the tools to deal with this.</p><h3 id=using-contextcontext>Using <code>context.Context</code><a hidden class=anchor aria-hidden=true href=#using-contextcontext>#</a></h3><p>That&rsquo;s right! We should be using a <code>context.Context</code> to manage the lifetimes of goroutines,
but that means we need to redefine our problem a bit; the expensive call also needs respect the use
of a <code>context.Context</code> we pass to it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ExpensiveServiceCallWithContext</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>point</span> <span class=nx>Point</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Really expensive call to remote service, but with a context
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>Now with <code>context.Context</code> in place we can re-write our function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ScatterShotSimpleWithContext</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>points</span> <span class=p>[]</span><span class=nx>Point</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithCancel</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nf>cancel</span><span class=p>()</span> <span class=c1>// This will cancel any in progress calls
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>bool</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>points</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>p</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>points</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>idx</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>point</span> <span class=nx>Point</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>ch</span> <span class=o>&lt;-</span> <span class=nf>ExpensiveServiceCallWithContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>point</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Point %d done\n&#34;</span><span class=p>,</span> <span class=nx>idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=k>range</span> <span class=nx>points</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=o>&lt;-</span><span class=nx>ch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The first time this was written I did not use <code>context.WithCancel()</code>, and <code>defer cancel()</code> in the
first few lines; however, this is necessary to make sure we stop any in-progress goroutines.
<code>ScatterShotSimpleWithContext()</code> shouldn&rsquo;t rely on the caller to cancel goroutines that it&rsquo;s
created.</p><p>It&rsquo;s looking better, but it could still overwhelm our &ldquo;expensive&rdquo; service! One way we could prevent
that is by limiting the amount of concurrency by not creating a goroutine per call, and instead use
a fixed pool of goroutines.</p><h3 id=limiting-concurrency>Limiting concurrency<a hidden class=anchor aria-hidden=true href=#limiting-concurrency>#</a></h3><p>Here&rsquo;s the solution I came up with for limiting concurrency. The caller is able to control the
amount of concurrency by passing a <code>maxConcurrency</code> parameter which limits the number of goroutines.
Goroutines are no longer created and passed a point for each element in <code>points</code> so some other
mechanism of passing points, to the already running goroutines, needs to be used. Sounds like a job for a
channel (it&rsquo;s important that it&rsquo;s buffered, more below).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ScatterShotLimitConcurrency</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>maxConcurrency</span> <span class=kt>int</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=nx>points</span> <span class=p>[]</span><span class=nx>Point</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithCancel</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nf>cancel</span><span class=p>()</span> <span class=c1>// This will cancel any in progress calls
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>pointsCh</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=nx>Point</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>resultCh</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>bool</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>points</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Avoid creating more goroutines than are necessary
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>maxConcurrency</span> <span class=p>&gt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>points</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>maxConcurrency</span> <span class=p>=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>points</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Use a goroutine to send points to the workers without delaying
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// this function.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nb>close</span><span class=p>(</span><span class=nx>pointsCh</span><span class=p>)</span> <span class=c1>//  Signal the workers we&#39;re done
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>p</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>points</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=nx>pointsCh</span> <span class=o>&lt;-</span> <span class=nx>p</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Start workers
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>maxConcurrency</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>for</span> <span class=nx>p</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>pointsCh</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>resultCh</span> <span class=o>&lt;-</span> <span class=nf>ExpensiveServiceCallWithContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=k>range</span> <span class=nx>points</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=o>&lt;-</span><span class=nx>resultCh</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>When implementing this there were some subtleties I missed on the first pass. The first, was feeding
points to workers in the main function instead of a goroutine could delay an early return because it
takes some amount of time to send all the points to a channel, even if it&rsquo;s buffered. This delay is
probably not significant for a small number of points, but sending points on a separate goroutine
also sets this up nicely for rate limiting (spoiler). Second, I didn&rsquo;t limit <code>maxConcurrency</code> when
it exceeds the number of points which results in creating more goroutines than are necessary to
solve the problem. Also, notice that sending on the unbuffered <code>pointsCh</code> might block so we also
need to have a case in the <code>select {}</code> block for when the context is done.</p><p>There&rsquo;s at least one major improvement we can make to our <code>ScatterShot()</code> function and that&rsquo;s to
limit the request rate in each of the worker goroutines.</p><h3 id=rate-limiting>Rate limiting<a hidden class=anchor aria-hidden=true href=#rate-limiting>#</a></h3><p>In all previous solutions, we process the <code>points</code> by calling the &ldquo;expensive&rdquo; service as fast as the
local machine can make the requests. This is likely to overwhelm the service. One possible solution
is to limit the total request rate by feeding <code>pointsCh</code> at a rate controlled by a <code>timer.Ticker</code>.
Because the <code>timer.Ticker</code> blocks execution of goroutine (or function) it can&rsquo;t be done in the body
of <code>ScatterShotRateLimited()</code> and it must be done on a separate goroutine.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ScatterShotRateLimited</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>maxConcurrency</span> <span class=kt>int</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=nx>reqsPerSec</span> <span class=kt>float64</span><span class=p>,</span> <span class=nx>points</span> <span class=p>[]</span><span class=nx>Point</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithCancel</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nf>cancel</span><span class=p>()</span> <span class=c1>// This will cancel any in progress calls
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>pointsCh</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=nx>Point</span><span class=p>,</span> <span class=nx>maxConcurrency</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>resultCh</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>bool</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>points</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Avoid creating more goroutines than are necessary
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>maxConcurrency</span> <span class=p>&gt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>points</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>maxConcurrency</span> <span class=p>=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>points</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Use a goroutine to feed points to the worker without blocking
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// this function.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nb>close</span><span class=p>(</span><span class=nx>pointsCh</span><span class=p>)</span> <span class=c1>//  Signal the workers we&#39;re done
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>		<span class=nx>delayPerReq</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Duration</span><span class=p>(</span><span class=nb>float64</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span> <span class=o>/</span> <span class=nx>reqsPerSec</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Send to workers at a rate of `reqsPerSec`
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>rateLimiter</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Tick</span><span class=p>(</span><span class=nx>delayPerReq</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>p</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>points</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=nx>pointsCh</span> <span class=o>&lt;-</span> <span class=nx>p</span><span class=p>:</span>
</span></span><span class=line><span class=cl>				<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>rateLimiter</span><span class=p>:</span>
</span></span><span class=line><span class=cl>				<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span>
</span></span><span class=line><span class=cl>					<span class=k>return</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>maxConcurrency</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>for</span> <span class=nx>p</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>pointsCh</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>resultCh</span> <span class=o>&lt;-</span> <span class=nf>ExpensiveServiceCallWithContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=k>range</span> <span class=nx>points</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=o>&lt;-</span><span class=nx>resultCh</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>One nuance here, is while waiting on the ticker we also need a <code>select{}</code> block case for the
context to break out when it&rsquo;s done.</p><h3 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h3><p>My initial solution to this problem was pretty rough, but I didn&rsquo;t give up! I
kept iterating and improving. After giving it a bit of thought, we now have solution that&rsquo;s
(hopefully) no more complex than it needs to be, plays nice with <code>context.Context</code>, doesn&rsquo;t leak
goroutines, and won&rsquo;t overwhelm the &ldquo;expensive&rdquo; service.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://penick.io/tags/golang/>golang</a></li><li><a href=https://penick.io/tags/concurrency/>concurrency</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://penick.io/>penick.io</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>