[{"content":"Recently, I came across a hypothetical Go concurrency problem. It\u0026rsquo;s a simple, toy problem that\u0026rsquo;s a potentially useful thought experiment for solving real-world problems. It\u0026rsquo;s also interesting because it has potential opportunity to be built on and improved. The problem goes like this, given:\ntype Point struct { // Stuff, doesn\u0026#39;t matter } func ExpensiveServiceCall(point Point) bool { // Really expensive call to remote service } func ScatterShot(points []Point) bool { // Implement me } you\u0026rsquo;re suppose to implement ScatterShot(point []Point) bool which returns true when one of the points \u0026ldquo;hits\u0026rdquo;, that is, when a call toExpensiveServiceCall(point Point) bool returns true. It should be implemented in such a way to minimize the run time when given a large number of points which (likely) means making multiple concurrent calls to the \u0026ldquo;expensive\u0026rdquo; service. After little bit of thought, I started work on the problem, and what I came up with was not very good.\nUnbounded channels My first attempt, uses a goroutine for each point in points sending the results back, to the outer function, on a unbounded channel. A sync.WaitGroup is used to prevent the outer function from returning before calculating all the results. Here\u0026rsquo;s what that looks like:\nfunc ScatterShotReallyBad(points []Point) bool { ch := make(chan bool) var wg sync.WaitGroup wg.Add(len(points)) go func() { wg.Wait() close(ch) }() for i, p := range points { go func(idx int, point Point) { r := ExpensiveServiceCall(point) if r { ch \u0026lt;- r // This can hang, causing a goroutine leak \t} wg.Done() fmt.Printf(\u0026#34;Point %d done\\n\u0026#34;, idx) }(i, p) } for r := range ch { return r } return false } If you run this, there will be times when goroutines will hang (and never return) because the unbounded channel blocks when there\u0026rsquo;s no longer a receiver which happens when the ScatterShot() function returns. So if you run something like:\nfunc main() { points := []Point{{}, {}, {}, {}, {}, {}, {}, {}, {}, {}} // 10 points \tScatterShotReallyBad(points) } the following can happen and some goroutines will fail to print that they\u0026rsquo;re done:\nPoint 2 done Point 3 done Point 9 done Point 8 done Point 4 done Point 5 done Point 7 done Point 0 done Point 1 done Where\u0026rsquo;s Point 6 done? Uh oh!\nOne potentially bad solution is to use a select{} block with a default: case to prevent the channel from blocking:\n// ... go func(idx int, point Point) { r := ExpensiveServiceCall(point) if r { select { case ch \u0026lt;- r: default: // If the channel blocks, take the default case  } } wg.Done() fmt.Printf(\u0026#34;Point %d done\\n\u0026#34;, idx) }(i, p) It prevents the goroutines from hanging (and leaking), but it creates another problem! Can you spot the problem?\nIt causes ScatterShotSimple() to, sporadically, return incorrect results. This is because it\u0026rsquo;s possible for goroutines to miss points that \u0026ldquo;hit\u0026rdquo; if the channel isn\u0026rsquo;t receiving yet in the outer function. In that situation, the select{} block chooses the default: case causing it to never send the result.\nUnbounded channels are not a good fit for this problem!\nBounded channels Not only does the initial solution not work correctly, it\u0026rsquo;s overly complex. It turns out that if you use a bounded channel then things fall into place and the solution is quite elegant. A bounded channel makes complete sense here because we know the total size of the problem we\u0026rsquo;re trying to solve: len(points), and this is size to use when creating the buffered channel:\nfunc ScatterShotSimple(points []Point) bool { ch := make(chan bool, len(points)) for i, p := range points { go func(idx int, point Point) { ch \u0026lt;- ExpensiveServiceCall(point) fmt.Printf(\u0026#34;Point %d done\\n\u0026#34;, idx) }(i, p) } for range points { if \u0026lt;-ch { return true } } return false } With this solution, the sender never blocks because the buffered channel is always big enough. The outer function doesn\u0026rsquo;t return prematurely because we wait for len(points) results on the shared channel before returning. This simple solution is quite nice, but it still has problems:\n It has a goroutine leak. If a point \u0026ldquo;hits\u0026rdquo; then the outer function returns immediately potentially leaving spawned goroutines running in the background. It creates an unbounded number of concurrent calls to the \u0026ldquo;expensive\u0026rdquo; service, potentially overwhelming it. Calls to the \u0026ldquo;expensive\u0026rdquo; service are made in a tight loop potentially causing a very high request rate that is also likely to overwhelm the service.  How might this be improved? Hint: Go gives us the tools to deal with this.\nUsing context.Context That\u0026rsquo;s right! We should be using a context.Context to manage the lifetimes of goroutines, but that means we need to redefine our problem a bit; the expensive call also needs respect the use of a context.Context we pass to it:\nfunc ExpensiveServiceCallWithContext(ctx context.Context, point Point) bool { // Really expensive call to remote service, but with a context } Now with context.Context in place we can re-write our function:\nfunc ScatterShotSimpleWithContext(ctx context.Context, points []Point) bool { ctx, cancel := context.WithCancel(ctx) defer cancel() // This will cancel any in progress calls  ch := make(chan bool, len(points)) for i, p := range points { go func(idx int, point Point) { ch \u0026lt;- ExpensiveServiceCallWithContext(ctx, point) fmt.Printf(\u0026#34;Point %d done\\n\u0026#34;, idx) }(i, p) } for range points { if \u0026lt;-ch { return true } } return false } The first time this was written I did not use context.WithCancel(), and defer cancel() in the first few lines; however, this is necessary to make sure we stop any in-progress goroutines. ScatterShotSimpleWithContext() shouldn\u0026rsquo;t rely on the caller to cancel goroutines that it\u0026rsquo;s created.\nIt\u0026rsquo;s looking better, but it could still overwhelm our \u0026ldquo;expensive\u0026rdquo; service! One way we could prevent that is by limiting the amount of concurrency by not creating a goroutine per call, and instead use a fixed pool of goroutines.\nLimiting concurrency Here\u0026rsquo;s the solution I came up with for limiting concurrency. The caller is able to control the amount of concurrency by passing a maxConcurrency parameter which limits the number of goroutines. Goroutines are no longer created and passed a point for each element in points so some other mechanism of passing points, to the already running goroutines, needs to be used. Sounds like a job for a channel (it\u0026rsquo;s important that it\u0026rsquo;s buffered, more below).\nfunc ScatterShotLimitConcurrency(ctx context.Context, maxConcurrency int, points []Point) bool { ctx, cancel := context.WithCancel(ctx) defer cancel() // This will cancel any in progress calls  pointsCh := make(chan Point) resultCh := make(chan bool, len(points)) // Avoid creating more goroutines than are necessary \tif maxConcurrency \u0026gt; len(points) { maxConcurrency = len(points) } // Use a goroutine to send points to the workers without delaying \t// this function. \tgo func() { defer close(pointsCh) // Signal the workers we\u0026#39;re done  for _, p := range points { select { case pointsCh \u0026lt;- p: case \u0026lt;-ctx.Done(): return } } }() // Start workers \tfor i := 0; i \u0026lt; maxConcurrency; i++ { go func() { for p := range pointsCh { resultCh \u0026lt;- ExpensiveServiceCallWithContext(ctx, p) } }() } for range points { if \u0026lt;-resultCh { return true } } return false } When implementing this there were some subtleties I missed on the first pass. The first, was feeding points to workers in the main function instead of a goroutine could delay an early return because it takes some amount of time to send all the points to a channel, even if it\u0026rsquo;s buffered. This delay is probably not significant for a small number of points, but sending points on a separate goroutine also sets this up nicely for rate limiting (spoiler). Second, I didn\u0026rsquo;t limit maxConcurrency when it exceeds the number of points which results in creating more goroutines than are necessary to solve the problem. Also, notice that sending on the unbuffered pointsCh might block so we also need to have a case in the select {} block for when the context is done.\nThere\u0026rsquo;s at least one major improvement we can make to our ScatterShot() function and that\u0026rsquo;s to limit the request rate in each of the worker goroutines.\nRate limiting In all previous solutions, we process the points by calling the \u0026ldquo;expensive\u0026rdquo; service as fast as the local machine can make the requests. This is likely to overwhelm the service. One possible solution is to limit the total request rate by feeding pointsCh at a rate controlled by a timer.Ticker. Because the timer.Ticker blocks execution of goroutine (or function) it can\u0026rsquo;t be done in the body of ScatterShotRateLimited() and it must be done on a separate goroutine.\nfunc ScatterShotRateLimited(ctx context.Context, maxConcurrency int, reqsPerSec float64, points []Point) bool { ctx, cancel := context.WithCancel(ctx) defer cancel() // This will cancel any in progress calls  pointsCh := make(chan Point, maxConcurrency) resultCh := make(chan bool, len(points)) // Avoid creating more goroutines than are necessary \tif maxConcurrency \u0026gt; len(points) { maxConcurrency = len(points) } // Use a goroutine to feed points to the worker without blocking \t// this function. \tgo func() { defer close(pointsCh) // Signal the workers we\u0026#39;re done  delayPerReq := time.Duration(float64(time.Second) / reqsPerSec) // Send to workers at a rate of `reqsPerSec` \trateLimiter := time.Tick(delayPerReq) for _, p := range points { select { case pointsCh \u0026lt;- p: select { case \u0026lt;-rateLimiter: case \u0026lt;-ctx.Done(): return } case \u0026lt;-ctx.Done(): return } } }() for i := 0; i \u0026lt; maxConcurrency; i++ { go func() { for p := range pointsCh { resultCh \u0026lt;- ExpensiveServiceCallWithContext(ctx, p) } }() } for range points { if \u0026lt;-resultCh { return true } } return false } One nuance here, is while waiting on the ticker we also need a select{} block case for the context to break out when it\u0026rsquo;s done.\nSummary My initial solution to this problem was pretty rough, but I didn\u0026rsquo;t give up! I kept iterating and improving. After giving it a bit of thought, we now have solution that\u0026rsquo;s (hopefully) no more complex than it needs to be, plays nice with context.Context, doesn\u0026rsquo;t leak goroutines, and won\u0026rsquo;t overwhelm the \u0026ldquo;expensive\u0026rdquo; service.\n","permalink":"https://penick.io/posts/bad-at-concurrency-part-1/","summary":"Recently, I came across a hypothetical Go concurrency problem. It\u0026rsquo;s a simple, toy problem that\u0026rsquo;s a potentially useful thought experiment for solving real-world problems. It\u0026rsquo;s also interesting because it has potential opportunity to be built on and improved. The problem goes like this, given:\ntype Point struct { // Stuff, doesn\u0026#39;t matter } func ExpensiveServiceCall(point Point) bool { // Really expensive call to remote service } func ScatterShot(points []Point) bool { // Implement me } you\u0026rsquo;re suppose to implement ScatterShot(point []Point) bool which returns true when one of the points \u0026ldquo;hits\u0026rdquo;, that is, when a call toExpensiveServiceCall(point Point) bool returns true.","title":"I'm Bad at Concurrency in Go"}]